/*
    This file is part of Ninja-lib

    Copyright (C) 2015 Benjamin Collins

    This library is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 2.1 or
    version 3 of the License.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library. If not, see <http://www.gnu.org/licenses/>.
*/

module.exports = (function(){

  return {
    //AFS : require("src/afs.js"),
    //GSL : require("src/gsl.js"),
    //BML : require("src/bml.js"),
    //PRS : require("src/prs.js"),

    read_njtl : function(addr, fp){
      fp.seek_set(addr);

      var texture_header = {
        list_addr : fp.read_dword(),
        num_textures : fp.read_dword()
      }

      //read the list
      var texture_list = [];
      fp.seek_set(texture_header.list_addr);
      for(var i = 0; i < texture_header.num_textures; i++){
        //read the address
        texture_list.push(fp.read_dword());
        //skip over empty bytes
        fp.seek_cur(8);
      }

      for(var i = 0; i < texture_list.length; i++){
        fp.seek_set(texture_list[i]);
        texture_list[i] = fp.read_str(32, true);
      }

      return texture_list;
    },

    read_node : function(offset, fp){
      fp.seek_set(offset);

      //read the njcm node
      var node = {
        flags : fp.read_dword(),
        model : fp.read_dword(),
        translation : {
          x : fp.read_single(),
          y : fp.read_single(),
          z : fp.read_single()
        },
        rotation : {
          x : fp.read_angle(),
          y : fp.read_angle(),
          z : fp.read_angle()
        },
        scale : {
          x : fp.read_single(),
          y : fp.read_single(),
          z : fp.read_single()
        },
        child : fp.read_dword(),
        sibling : fp.read_dword()
      };

      var f = node.flags;
      var flags = {};

      flags.translate = !(f & 0b00000001);
      flags.rotate = !(f & 0b00000010);
      flags.scale = !(f & 0b00000100);
      flags.draw = !(f & 0b00001000);
      flags.trace = !(f & 0b00010000);
      flags.lwo_order = f & 0b00100000;
      flags.skip = f & 0b01000000;
      flags.skip_shape = f & 0b10000000;
      flags.pushpop = !flags.translate && !flags.rotate && !flags.scale;

      for(field in flags){
        flags[field] = Boolean(flags[field]);
        flags[field] = Number(flags[field]);
      }

      node.flags = flags;

      return node;
    }

  };

})();
